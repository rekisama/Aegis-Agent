#!/usr/bin/env python3
"""
动态工具创建系统演示
演示Agent如何自动创建和使用新工具
"""

import asyncio
import json
import logging
from pathlib import Path

# 设置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# 添加项目根目录到Python路径
import sys
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from python.agent.core import Agent
from python.utils.config import load_config

async def demo_agent_creating_tools():
    """演示Agent创建新工具"""
    
    print("=== Agent动态工具创建演示 ===\n")
    
    # 初始化Agent
    config = load_config()
    agent = Agent(config)
    
    print("1. 初始化Agent完成")
    print(f"   可用工具数量: {len(agent.tools)}")
    print(f"   工具列表: {list(agent.tools.keys())}\n")
    
    # 示例1：Agent自动检测需要创建工具
    print("2. 测试自动工具创建")
    task1 = "帮我创建一个工具，可以计算斐波那契数列的第n项"
    print(f"   任务: {task1}")
    
    result1 = await agent.execute_task(task1)
    print(f"   结果: {json.dumps(result1, ensure_ascii=False, indent=2)}\n")
    
    # 示例2：手动创建工具
    print("3. 手动创建工具")
    tool_spec = {
        "name": "string_processor",
        "description": "字符串处理工具，支持反转、大写、小写等操作",
        "code": """
def process_string(text, operation):
    if not isinstance(text, str):
        raise ValueError("输入必须是字符串")
    
    if operation == "reverse":
        return text[::-1]
    elif operation == "upper":
        return text.upper()
    elif operation == "lower":
        return text.lower()
    elif operation == "title":
        return text.title()
    elif operation == "length":
        return len(text)
    else:
        raise ValueError(f"不支持的操作: {operation}")

result = process_string(text, operation)
""",
        "parameters": {
            "text": "要处理的字符串",
            "operation": "操作类型 (reverse/upper/lower/title/length)"
        }
    }
    
    print("   创建工具规范...")
    creation_result = await agent.create_new_tool(tool_spec)
    print(f"   创建结果: {json.dumps(creation_result, ensure_ascii=False, indent=2)}\n")
    
    # 示例3：使用新创建的工具
    if creation_result["success"]:
        print("4. 使用新创建的工具")
        task2 = "使用string_processor工具将'Hello World'转换为大写"
        print(f"   任务: {task2}")
        result2 = await agent.execute_task(task2)
        print(f"   结果: {json.dumps(result2, ensure_ascii=False, indent=2)}\n")
    
    # 示例4：查看工具统计
    print("5. 查看工具统计")
    stats = agent.dynamic_tool_creator.get_tool_statistics()
    print(f"   统计信息: {json.dumps(stats, ensure_ascii=False, indent=2)}\n")
    
    # 示例5：测试工具验证
    print("6. 测试工具验证")
    invalid_tool_spec = {
        "name": "dangerous_tool",
        "description": "危险工具",
        "code": """
import os
import subprocess

def dangerous_operation():
    os.system("rm -rf /")  # 危险操作
    return "dangerous"

result = dangerous_operation()
""",
        "parameters": {}
    }
    
    print("   测试危险工具创建...")
    validation_result = await agent._validate_tool_spec_with_llm(invalid_tool_spec)
    if validation_result is None:
        print("   ✅ 危险工具被正确拦截")
    else:
        print("   ❌ 危险工具未被拦截")
    print()

async def demo_web_interface():
    """演示Web界面功能"""
    print("=== Web界面功能演示 ===\n")
    
    print("1. 启动Web服务器")
    print("   运行: python web/start_server.py")
    print("   访问: http://localhost:8000")
    print()
    
    print("2. 工具管理功能")
    print("   - 点击侧边栏的'工具管理'按钮")
    print("   - 创建新工具")
    print("   - 查看工具列表")
    print("   - 测试和删除工具")
    print()
    
    print("3. API端点")
    print("   - POST /api/tools/create - 创建工具")
    print("   - GET /api/tools/dynamic - 获取工具列表")
    print("   - DELETE /api/tools/dynamic/{name} - 删除工具")
    print("   - POST /api/tools/dynamic/{name}/test - 测试工具")
    print()

async def demo_file_monitoring():
    """演示文件监控功能"""
    print("=== 文件监控功能演示 ===\n")
    
    print("1. 实时文件监控")
    print("   - 监控 python/tools/dynamic/ 目录")
    print("   - 自动检测新工具文件")
    print("   - 热加载工具更新")
    print()
    
    print("2. 手动创建工具文件示例")
    example_tool = '''
"""
Dynamic Tool: calculator
Auto-generated by Agent
"""

import json
import logging
from typing import Dict, Any
from python.tools.base import BaseTool, ToolResult

class DynamicCalculatorTool(BaseTool):
    """Dynamic tool: calculator"""
    
    def __init__(self):
        super().__init__()
        self.name = "calculator"
        self.description = "Dynamic tool created by agent"
    
    async def execute(self, **kwargs) -> ToolResult:
        """Execute the dynamic tool"""
        try:
            # 参数验证
            a = kwargs.get('a', 0)
            b = kwargs.get('b', 0)
            operation = kwargs.get('operation', 'add')
            
            # 执行计算
            if operation == 'add':
                result = a + b
            elif operation == 'subtract':
                result = a - b
            elif operation == 'multiply':
                result = a * b
            elif operation == 'divide':
                result = a / b if b != 0 else 'Error: Division by zero'
            else:
                result = f'Error: Unknown operation {operation}'
            
            return ToolResult(
                success=True,
                data={"result": result},
                error=None
            )
            
        except Exception as e:
            return ToolResult(
                success=False,
                data={},
                error=str(e)
            )
'''
    
    tool_file = Path("python/tools/dynamic/dynamic_calculator.py")
    tool_file.write_text(example_tool, encoding='utf-8')
    print(f"   创建示例工具文件: {tool_file}")
    print("   文件监控将自动检测并加载此工具")
    print()

async def main():
    """主演示函数"""
    print("🚀 开始动态工具创建系统演示\n")
    
    try:
        # 演示Agent核心功能
        await demo_agent_creating_tools()
        
        # 演示Web界面
        await demo_web_interface()
        
        # 演示文件监控
        await demo_file_monitoring()
        
        print("✅ 演示完成！")
        print("\n📝 总结:")
        print("   - Agent能够自动检测任务需求并创建新工具")
        print("   - 工具创建过程包含安全验证")
        print("   - Web界面提供完整的工具管理功能")
        print("   - 文件系统监控支持实时工具发现")
        print("   - 系统具备完整的自我进化能力")
        
    except Exception as e:
        print(f"❌ 演示过程中出现错误: {e}")
        logging.error(f"演示失败: {e}")

if __name__ == "__main__":
    asyncio.run(main()) 