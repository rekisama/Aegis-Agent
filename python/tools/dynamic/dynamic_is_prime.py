"""
Dynamic Tool: is_prime
Auto-generated by Agent
"""

import json
import logging
from typing import Dict, Any
import sys
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from python.tools.base import BaseTool, ToolResult


class DynamicIs_primeTool(BaseTool):
    """Dynamic tool: is_prime"""
    
    def __init__(self):
        super().__init__()
        self.name = "is_prime"
        self.description = "Dynamic tool created by agent"
        # 存储实际的代码
        self.code = """def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w
    return True"""
    
    async def execute(self, **kwargs) -> ToolResult:
        """Execute the dynamic tool"""
        try:
            # 参数验证
            validated_params = self._validate_parameters(kwargs)
            
            # 执行动态代码
            result = self._execute_dynamic_code(validated_params)
            
            return ToolResult(
                success=True,
                data={"result": result},
                error=None
            )
            
        except Exception as e:
            return ToolResult(
                success=False,
                data={},
                error=str(e)
            )
    
    def _validate_parameters(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """验证参数"""
        try:
            validated_params = {}
            
            for key, value in params.items():
                # 基本类型检查
                if not isinstance(key, str):
                    logging.warning(f"Invalid parameter key type: {type(key)}")
                    continue
                
                # 值验证
                if value is None:
                    logging.warning(f"Parameter '{key}' is None")
                    continue
                
                # 字符串长度限制
                if isinstance(value, str) and len(value) > 10000:
                    logging.warning(f"Parameter '{key}' string too long: {len(value)} characters")
                    value = value[:10000] + "..."
                
                # 列表长度限制
                if isinstance(value, list) and len(value) > 1000:
                    logging.warning(f"Parameter '{key}' list too long: {len(value)} items")
                    value = value[:1000]
                
                # 字典深度限制
                if isinstance(value, dict):
                    value = self._validate_dict_depth(value, max_depth=5)
                
                validated_params[key] = value
            
            return validated_params
            
        except Exception as e:
            logging.error(f"Parameter validation failed: {e}")
            return params
    
    def _validate_dict_depth(self, data: Dict[str, Any], max_depth: int = 5, current_depth: int = 0) -> Dict[str, Any]:
        """验证字典深度，防止过深的嵌套"""
        if current_depth >= max_depth:
            logging.warning(f"Dictionary depth limit reached: {current_depth}")
            return {"error": "Dictionary too deep"}
        
        validated = {}
        for key, value in data.items():
            if isinstance(value, dict):
                validated[key] = self._validate_dict_depth(value, max_depth, current_depth + 1)
            else:
                validated[key] = value
        
        return validated
    
    def _execute_dynamic_code(self, params: Dict[str, Any]) -> Any:
        """执行动态代码"""
        try:
            # 创建局部变量环境
            local_vars = {}
            local_vars.update(params)
            
            # 执行代码（定义函数）
            exec(self.code, {}, local_vars)
            
            # 智能检测可调用的函数
            callable_functions = []
            for name, obj in local_vars.items():
                if callable(obj) and not name.startswith('_'):
                    callable_functions.append(name)
            
            if callable_functions:
                # 选择最合适的函数
                # 优先选择与工具名相同的函数
                tool_name = self.name
                if tool_name in callable_functions:
                    selected_function = tool_name
                else:
                    # 否则选择第一个可调用函数
                    selected_function = callable_functions[0]
                
                # 调用选中的函数
                func = local_vars[selected_function]
                if params:
                    # 尝试调用函数，传递参数
                    try:
                        # 如果函数接受参数，传递第一个参数
                        first_param = next(iter(params.values()))
                        return func(first_param)
                    except (TypeError, ValueError):
                        # 如果参数类型不匹配，尝试无参数调用
                        return func()
                else:
                    # 无参数调用
                    return func()
            
            # 如果没有找到可调用函数，检查是否有 result 变量
            if 'result' in local_vars:
                return local_vars['result']
            
            # 如果都没有，返回执行后的局部变量
            return local_vars
            
        except Exception as e:
            logging.error(f"Dynamic code execution failed: {e}")
            return None
